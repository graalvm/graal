Using the ptototype debug info feature
--------------------------------------

To add debug info to a generated native image add flag
-H:+TrackNodeSourcePosition to the native image command line.

  mx native-image -H:+TrackNodeSourcePosition Hello.java

The resulting image should contain code (method) debug symbols.

What is currently implemented
-----------------------------

The currently implemented features include:

  - break points configured by file and line or by method name
  - single stepping by line including both into and over function calls
  - stack backtraces (not including frames detailing inlined code)

Note that single stepping within a compiled method includes file and
line number info for inlined code, including inlined Graal methods.
So, gdb may switch files even though you are still in the same
compiled method.

Identifying the location of source code
---------------------------------------

In order for gdb to be able to locate the source files for your app
methods, Graal methods and JDK runtime methods you need to provide gdb
with a list of source root dirs a 'set directories' command:

    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...

The argument is a comma separated list of source roots. It needs to
identify:

  - sources for your app
  - sources under the Graal sdk, compiler, substratevm and truffle trees
  - sources in the JDK src.zip file

Needless to say the list for Graal is long and complex. Also, the JDK
sources are in a zip file and gdb does not understand zip sources. So
you need to extract the JDK sources as a preparatory step,

You can use shell script write_gdbsourcepath (added to Graal dir
substratevm) to auto-generate settings for the GRaal and JDK sources.

    $ bash write_gdbsourcepath

It creates a local file .gdbsourcepath which sets the relevant
directories. Before running it you can set two env vars to tell it
where to locate the source trees it needs to include:

  - GRAAL_JAVA_SRC_ROOT should point to the dir into which you have
  unzipped the src.zip from your Graal JDK release
  - GRAAL_SRC_ROOT should point to the dir in which your Graal git
  tree checkout is located

Note that the script ignores test source dirs and jdk dirs that do not
match the release level of the JDK (i.e. if you use jdk8 it will ony
include jdk8 src dirs). The script runs the java command available via
JAVA_HOME to idenitfy which JDK is in use).

If you run the script from the substratevm dir of your Graal git repo
checkout the script will default GRAAL_SRC_ROOT to the parent dir.

If JAVA_HOME is set the script will default GRAAL_JAVA_SRC_ROOT to
$JAVA_HOME/src

Checking debug info
-------------------

The objdump command can be used to display the dbeug info embedded
into a native image. The following commands (which all assume the
target binary is called hello) can be used to display all currentyl
generated content:

    $ objdump --dwarf=info hello > info
    $ objdump --dwarf=abbrev hello > abbrev
    $ objdump --dwarf=ranges hello > ranges
    $ objdump --dwarf=decodedline hello > decodedline
    $ objdump --dwarf=rawline hello > rawline
    $ objdump --dwarf=str hello > str
    $ objdump --dwarf=frames hello > frames

The *info* section includes details of all compiled Java methods.

The *abbrev* sectio defines the layout of records in the info section
that describe Java files (compilation units) and methods.

The *ranges* section details the start and end addresses of method
code segments

The *decodedline* section maps subsegments of method code range
segments to files and line numbers. This mapping includes entries
for files and line numbers for inlined methods.

The *rawline* segment provides deatails of how the line table is
generated using DWARF state machine instuctions that encode file,
line and address transitions.

The *str* section provides a lookup table for strings referenced
from records in the info section

The *frames* section lists transition points in compiled methods
where a (fixed size) stack frame is pushed or popped, allowing
the debugger to identify each frame's current and previous stack
pointers and it's return address.

Note that some of the content embedded in the debug records is
generated by the C compiler and belongs to code that is either in
libraries or the C lib bootstrap code that is bundled in with the
Java method code.

Currently supported targets
---------------------------

The prototype is currently implemented only for gdb on Linux.

  - Linux/x86_64 suppoort has been tested and should work
    correctly.

  - Linux/AArch64 support is present but has not yet been fully
    verified (break points should work ok but stack backtraces
    may be incorrect).

Windows support is still under development.
